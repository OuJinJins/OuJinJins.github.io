<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OJJ的博客</title>
  
  <subtitle>这是一只欧金金的分身</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-05T19:43:39.366Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>OuJinJins</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图文了解KMP</title>
    <link href="http://example.com/2022/11/06/%E5%9B%BE%E6%96%87%E4%BA%86%E8%A7%A3KMP/"/>
    <id>http://example.com/2022/11/06/%E5%9B%BE%E6%96%87%E4%BA%86%E8%A7%A3KMP/</id>
    <published>2022-11-05T19:40:20.000Z</published>
    <updated>2022-11-05T19:43:39.366Z</updated>
    
    <content type="html"><![CDATA[<p>KMP用于解决串匹配问题</p><h1 id="图解KMP"><a href="#图解KMP" class="headerlink" title="图解KMP"></a>图解KMP</h1><p><img src="https://dsvision.net/git/jiajun_ou/ImageBed/raw/master/image/KMP.jpg" alt="KMP图解"></p><h1 id="KMP代码Go语言实现"><a href="#KMP代码Go语言实现" class="headerlink" title="KMP代码Go语言实现"></a>KMP代码Go语言实现</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">// 生成next数组</span></span><br><span class="line">   <span class="comment">// next 数组下标的含义为包括当前下标的字符串前缀长度</span></span><br><span class="line">   <span class="comment">// 也为模式串对应下标元素的下一个字符的下标</span></span><br><span class="line">   next := getNext(s2)</span><br><span class="line">   j := <span class="number">0</span></span><br><span class="line">   <span class="comment">// i遍历文本串, j遍历模式串</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s1); i++ &#123;</span><br><span class="line">      <span class="comment">// j &gt; 0 防止死循环 因为前缀表[0] = 0</span></span><br><span class="line">      <span class="comment">// 若j ！= 0且不匹配 j跳到前缀的后一个元素下标进行匹配即next[j-1]</span></span><br><span class="line">      <span class="comment">// 直到匹配成功或到达模式串头 即j = 0</span></span><br><span class="line">      <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; s1[i] != s2[j] &#123;</span><br><span class="line">         j = next[j<span class="number">-1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若当前字符匹配成功</span></span><br><span class="line">      <span class="comment">// 为什么要加判断，因为可能存在j = 0的情况但没有匹配成功</span></span><br><span class="line">      <span class="keyword">if</span> s1[i] == s2[j] &#123;</span><br><span class="line">         j++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若整个模式串都匹配完成</span></span><br><span class="line">      <span class="keyword">if</span> j == <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">         <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成next数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">// 生成next数组与KMP如出一辙</span></span><br><span class="line">   <span class="comment">// 只是next在遍历后缀(文本串)中在每次遍历前缀(模式串)字符匹配成功的时候都会记录</span></span><br><span class="line">   <span class="comment">// 而KMP在模式串匹配完成后返回</span></span><br><span class="line">   j := <span class="number">0</span></span><br><span class="line">   next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">   next[<span class="number">0</span>] = j</span><br><span class="line">   <span class="comment">// i为遍历后缀(文本串)，j为遍历前缀()</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j] &#123;</span><br><span class="line">         <span class="comment">// 会利用之前的next</span></span><br><span class="line">         <span class="comment">// 后缀已经有最长next[j-1]个元素与前缀相同</span></span><br><span class="line">         <span class="comment">// 一步步缩短相同的元素个数</span></span><br><span class="line">         <span class="comment">// 直到匹配成功 或 到达头退出此时i子串的最长相同前缀长度为默认值0</span></span><br><span class="line">         j = next[j<span class="number">-1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 匹配成功j++</span></span><br><span class="line">      <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">         j++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录当前 i子串的最长相同前缀长度</span></span><br><span class="line">      next[i] = j</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="最大重复字符串"><a href="#最大重复字符串" class="headerlink" title="最大重复字符串"></a><a href="https://leetcode.cn/problems/maximum-repeating-substring/">最大重复字符串</a></h2><p>题解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxRepeating</span><span class="params">(sequence <span class="keyword">string</span>, word <span class="keyword">string</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 动归 dp[i] 代表了sequence[i+1-len(word):i+1]匹配成功word后的连续重复值</span></span><br><span class="line">    <span class="comment">// 若匹配成功 且 i &lt; m 则dp[i] = 1 (此处为处理匹配成功但i - m不存在的情况)</span></span><br><span class="line">    <span class="comment">// 若匹配成功 且 i &gt;= m 则dp[i] = dp[i - m] + 1</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(sequence))</span><br><span class="line">    <span class="comment">// 生成next数组</span></span><br><span class="line">    <span class="comment">// next 数组下标的含义为包括当前下标的字符串前缀长度</span></span><br><span class="line">    <span class="comment">// 也为模式串对应下标元素的下一个字符的下标</span></span><br><span class="line">    next := getNext(word)</span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    <span class="comment">// i遍历文本串, j遍历模式串</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sequence); i++ &#123;</span><br><span class="line">        <span class="comment">// j &gt; 0 防止死循环 因为前缀表[0] = 0</span></span><br><span class="line">        <span class="comment">// 若j ！= 0且不匹配 j跳到前缀的后一个元素下标进行匹配即next[j-1]</span></span><br><span class="line">        <span class="comment">// 直到匹配成功或到达模式串头 即j = 0</span></span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; sequence[i] != word[j] &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若当前字符匹配成功</span></span><br><span class="line">        <span class="comment">// 为什么要加判断，因为可能存在j = 0的情况但没有匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> sequence[i] == word[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若整个模式串都匹配完成</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(word) &#123;</span><br><span class="line">            <span class="keyword">if</span> i - <span class="built_in">len</span>(word) &lt; <span class="number">0</span>&#123;</span><br><span class="line">                dp[i] = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="built_in">len</span>(word)] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此处j已经是len(word) 那么next[j - 1]表示word整个字符串的前后缀长度</span></span><br><span class="line">            <span class="comment">// 此处跳转方便下一个字符利用后缀匹配</span></span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt; ans &#123;</span><br><span class="line">            ans = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成next数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 生成next数组与KMP如出一辙</span></span><br><span class="line">    <span class="comment">// 只是next在遍历后缀(文本串)中在每次遍历前缀(模式串)字符匹配成功的时候都会记录</span></span><br><span class="line">    <span class="comment">// 而KMP在模式串匹配完成后返回</span></span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    next[<span class="number">0</span>] = j</span><br><span class="line">    <span class="comment">// i为遍历后缀(文本串)，j为遍历前缀()</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j] &#123;</span><br><span class="line">            <span class="comment">// 会利用之前的next</span></span><br><span class="line">            <span class="comment">// 后缀已经有最长next[j-1]个元素与前缀相同</span></span><br><span class="line">            <span class="comment">// 一步步缩短相同的元素个数</span></span><br><span class="line">            <span class="comment">// 直到匹配成功 或 到达头退出此时i子串的最长相同前缀长度为默认值0</span></span><br><span class="line"></span><br><span class="line">            j = next[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配成功j++</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录当前 i子串的最长相同前缀长度</span></span><br><span class="line">        next[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;KMP用于解决串匹配问题&lt;/p&gt;
&lt;h1 id=&quot;图解KMP&quot;&gt;&lt;a href=&quot;#图解KMP&quot; class=&quot;headerlink&quot; title=&quot;图解KMP&quot;&gt;&lt;/a&gt;图解KMP&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://dsvision.net/git/jia</summary>
      
    
    
    
    
    <category term="KMP" scheme="http://example.com/tags/KMP/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TyPora+Gitee+Picgo舒适写笔记</title>
    <link href="http://example.com/2021/11/11/TyPora+Gitee+Picgo%E8%88%92%E9%80%82%E5%86%99%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/11/11/TyPora+Gitee+Picgo%E8%88%92%E9%80%82%E5%86%99%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-11T11:16:20.000Z</published>
    <updated>2022-11-03T09:09:18.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gitee仓库"><a href="#Gitee仓库" class="headerlink" title="Gitee仓库"></a>Gitee仓库</h1><ul><li><p>登录 Gitee 官网，点击新建仓库</p></li><li><p>输入仓库名称，<strong>选择公开（坑）</strong>,点击创建</p></li></ul><p>示例如下图</p><p><img src="https://gitee.com/oujinjins/imagebed/raw/master/image/image-20211111204602888.png" alt="image-20211111204602888"></p><ul><li>进入gitee个人设置创建私人令牌</li></ul><p><img src="https://gitee.com/oujinjins/imagebed/raw/master/image/image-20211111204816518.png" alt="image-20211111204816518"></p><ul><li>权限只选择图中两个即可</li></ul><img src="https://gitee.com/oujinjins/imagebed/raw/master/image/image-20211111205103101.png" alt="image-20211111205103101" style="zoom: 67%;"> <h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p><code>PicGo</code> 是一款开源的用于快速上传图片并获取图片<code>URL</code>链接的工具</p><ul><li><strong><a href="https://link.zhihu.com/?target=https://picgo.github.io/PicGo-Doc/">说明文档</a></strong></li><li><strong><a href="https://link.zhihu.com/?target=https://github.com/Molunerfinn/">下载链接</a></strong></li></ul><p>安装完成后打开主界面进行插件配置</p><p>如果在左边「图床设置」下面没有看到<code>Gitee</code>选项，那么需要你自己安装插件</p><p><strong>在左「插件设置」选项中，搜索<code>Gitee</code>即可出现对应的插件，点击安装即可</strong></p><p><strong>安装成功后边可以看到对应图床设置了，打开「Gitee图床」配置一些仓库信息和 token</strong></p><p><img src="https://dsvision.net/git/jiajun_ou/ImageBed/src/branch/master/image/image-20211111205032741.png" alt="image-20211111205032741"></p><p>填写说明</p><ul><li>owner:仓库持有者，填写你 <code>Gitee</code>用户名即可;</li><li>repo: 仓库名称，填写你在创建图床时的仓库名字，这里注意带上你的用户名哈，比如我的是<code>devstone/ImageBed</code>;</li><li>path: 填写仓库下面某个文件夹名字，也就是你存放图片的位置，比如我的是在<code>images</code>,这个名字要和你仓库中创建的对应哈；</li><li>token: 这个比较重要，就是上面创建仓库后创建的私人令牌明文，直接粘贴上去就行，如果忘记了那么直接删除重新再创建了</li><li>message：这个不用填写也行</li></ul><p>最后「确认」后直接就可以使用了，记得点击下「设置为默认图床」</p><h1 id="Typora-配置"><a href="#Typora-配置" class="headerlink" title="Typora 配置"></a>Typora 配置</h1><p>接下来可以在 <code>Typora</code>中接入我们的图床了。</p><ul><li><p>打开<code>Typora</code>，找到<code>偏好设置</code></p><img src="https://gitee.com/oujinjins/imagebed/raw/master/image/20201216221310291.png" alt="在这里插入图片描述" style="zoom: 80%;"></li><li><p>进行如下配置</p><p><img src="https://gitee.com/oujinjins/imagebed/raw/master/image/20201216222009920.png" alt="在这里插入图片描述"></p></li><li><p>最后检验图床对接是否成功，点击 “<code>验证图片上传选项</code>” ，成功就会显示获取成功。</p></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>PicGo</code> 上传图片有两种方式</p><ul><li>拖拽到主界面上传区域</li><li>使用快捷键上传剪贴板图片，后者效率更高更方便</li></ul><p><code>Typora</code>记录笔记时可直接将截图的图片粘贴入笔记中，会自动上传</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>gitee大于1M的图片无法load(待解决)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gitee仓库&quot;&gt;&lt;a href=&quot;#Gitee仓库&quot; class=&quot;headerlink&quot; title=&quot;Gitee仓库&quot;&gt;&lt;/a&gt;Gitee仓库&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登录 Gitee 官网，点击新建仓库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输入仓库名</summary>
      
    
    
    
    
    <category term="Typora" scheme="http://example.com/tags/Typora/"/>
    
    <category term="Gitee" scheme="http://example.com/tags/Gitee/"/>
    
    <category term="Picgo" scheme="http://example.com/tags/Picgo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Typora + 开发Hexo插件 解决图片路径不一致</title>
    <link href="http://example.com/2021/11/10/hexo/"/>
    <id>http://example.com/2021/11/10/hexo/</id>
    <published>2021-11-10T15:39:20.000Z</published>
    <updated>2022-11-03T09:09:18.467Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考并简化于<a href="https://moeci.com/posts/hexo-typora/">https://moeci.com/posts/hexo-typora/</a></strong></p><h2 id="1-配置-Typora-图片路径"><a href="#1-配置-Typora-图片路径" class="headerlink" title="1. 配置 Typora 图片路径"></a>1. 配置 Typora 图片路径</h2><p><img src="/2021/11/10/hexo/hexo0.png"></p><p>图片文件保存路径: <code>./$&#123;filename&#125;</code> 即保存到与 当前正在编辑的文件名 相同的同级文件夹下</p><p>下面三项依次为</p><ul><li><p>对本地位置的图片应用上述规则</p></li><li><p>对网络位置的图片应用上述规则</p></li><li><p>优先使用相对路径</p><p>建议都勾选上，至少要勾选上第一项</p></li></ul><blockquote><p>PS：使用 <code>Ctrl+V</code> 粘贴 即可复制图片到Typora图片文件夹</p></blockquote><h2 id="2-配置-Hexo-图片文件夹"><a href="#2-配置-Hexo-图片文件夹" class="headerlink" title="2. 配置 Hexo 图片文件夹"></a>2. 配置 Hexo 图片文件夹</h2><p>在 Hexo 根目录打开配置文件 <code>_config.yml</code></p><p>搜索 <code>post_asset_folder</code>，<code>false</code> 改为 <code>true</code></p><p>这样修改后，每次 ‘hexo new page’ 生成新文章，都会在文章文件同级目录创建一个与文章文件名同名的文件夹，我们就在这里存放此文章的图片。</p><blockquote><p>PS: 这被称为 <code>文章资源文件夹</code>, 参考官方文档： <a href="https://hexo.io/zh-cn/docs/asset-folders">https://hexo.io/zh-cn/docs/asset-folders</a></p></blockquote><h2 id="3-安装-Hexo-转换图片路径-插件"><a href="#3-安装-Hexo-转换图片路径-插件" class="headerlink" title="3. 安装 Hexo 转换图片路径 插件"></a>3. 安装 Hexo 转换图片路径 插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>但是这个插件的内容需要修改【不然可能会出Bug】</p><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line"><span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line"><span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">  <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p><img src="/2021/11/10/hexo/hexo1.png"></p><p>使用方式示例(图中hexo.md)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">example</span>](<span class="link">hexo/example.jpg</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;参考并简化于&lt;a href=&quot;https://moeci.com/posts/hexo-typora/&quot;&gt;https://moeci.com/posts/hexo-typora/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-配置-Typora-图片</summary>
      
    
    
    
    
    <category term="Typora" scheme="http://example.com/tags/Typora/"/>
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://example.com/2021/10/01/redis/"/>
    <id>http://example.com/2021/10/01/redis/</id>
    <published>2021-09-30T17:18:20.000Z</published>
    <updated>2022-11-03T09:09:18.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Nosql概述"><a href="#一、Nosql概述" class="headerlink" title="一、Nosql概述"></a>一、Nosql概述</h2><h3 id="为什么使用Nosql"><a href="#为什么使用Nosql" class="headerlink" title="为什么使用Nosql"></a>为什么使用Nosql</h3><blockquote><p>1、单机Mysql时代</p></blockquote><p><img src="/img/img1.png"></p><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p><ol><li>数据量增加到一定程度，单机数据库就放不下了</li><li>数据的索引（B+ Tree）,一个机器内存也存放不下</li><li>访问量变大后（读写混合），一台服务器承受不住。</li></ol><blockquote><p>4、如今最近的年代</p></blockquote><p> 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p><blockquote><p>目前一个基本的互联网项目</p></blockquote><p><img src="/img/img2.png"></p><p>为什么要用NoSQL ？</p><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！<br>这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p><p>什么是Nosql<br>NoSQL = Not Only SQL（不仅仅是SQL）</p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，<strong>Redis是发展最快的。</strong></p><p>Nosql特点<br>方便扩展（数据之间没有关系，很好扩展！）</p><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p><p>传统的 RDBMS 和 NoSQL</p><p>​       传统的 RDBMS(关系型数据库)</p><ul><li>结构化组织</li><li>SQL</li><li>数据和关系都存在单独的表中 row col</li><li>操作，数据定义语言</li><li>严格的一致性</li><li>基础的事务</li><li>…<br>Nosql</li><li>不仅仅是数据</li><li>没有固定的查询语言</li><li>键值对存储，列存储，文档存储，图形数据库（社交关系）</li><li>最终一致性</li><li>CAP定理和BASE</li><li>高性能，高可用，高扩展</li><li>…</li></ul><blockquote><p>了解：3V + 3高</p></blockquote><p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p><ol><li>海量Velume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><h2 id="二、Redis入门"><a href="#二、Redis入门" class="headerlink" title="二、Redis入门"></a>二、Redis入门</h2><p>概述<br>Redis是什么？</p><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><blockquote><p>Redis能该干什么？</p></blockquote><ul><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li></ul><blockquote><p>特性</p></blockquote><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>redis默认有16个数据库</p></blockquote><p><strong>Redis的默认端口6379</strong></p><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p><blockquote><p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p></blockquote><p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p><p>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</p><blockquote><p><strong>Redis为什么单线程还这么快？</strong></p></blockquote><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li></ul><p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p><h2 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h2><p> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库</strong>，<strong>高速缓存</strong>和<strong>消息队列代理</strong>。它支持<a href="https://www.redis.net.cn/tutorial/3508.html">字符串</a>、<a href="https://www.redis.net.cn/tutorial/3509.html">哈希表</a>、<a href="https://www.redis.net.cn/tutorial/3510.html">列表</a>、<a href="https://www.redis.net.cn/tutorial/3511.html">集合</a>、<a href="https://www.redis.net.cn/tutorial/3512.html">有序集合</a>，<a href="https://www.redis.net.cn/tutorial/3508.html">位图</a>，<a href="https://www.redis.net.cn/tutorial/3513.html">hyperloglogs</a>等数据类型。内置复制、<a href="https://www.redis.net.cn/tutorial/3516.html">Lua脚本</a>、LRU收回、<a href="https://www.redis.net.cn/tutorial/3515.html">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a href="https://www.redis.net.cn/tutorial/3524.html">分区</a>。</p><h3 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h3><blockquote><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p></blockquote><p>下面学习的命令：</p><ul><li><code>exists key</code>：判断键是否存在</li><li><code>del key</code>：删除键值对</li><li><code>move key db</code>：将键值对移动到指定数据库</li><li><code>expire key second</code>：设置键值对的过期时间</li><li><code>type key</code>：查看value的数据类型</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys * # 查看当前数据库所有key</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name qinjiang # <span class="built_in">set</span> key</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">20</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) &quot;age&quot;</span><br><span class="line"><span class="number">2</span>) &quot;name&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">move</span> age <span class="number">1</span> # 将键值对移动到指定数据库</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; EXISTS age # 判断键是否存在</span><br><span class="line">(integer) <span class="number">0</span> # 不存在</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; EXISTS name</span><br><span class="line">(integer) <span class="number">1</span> # 存在</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SELECT <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>[<span class="number">1</span>]&gt; keys *</span><br><span class="line"><span class="number">1</span>) &quot;age&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>[<span class="number">1</span>]&gt; <span class="built_in">del</span> age # 删除键值对</span><br><span class="line">(integer) <span class="number">1</span> # 删除个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> age <span class="number">20</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; EXPIRE age <span class="number">15</span> # 设置键值对的过期时间</span><br><span class="line"></span><br><span class="line">(integer) <span class="number">1</span> # 设置成功 开始计数</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl age # 查看key的过期剩余时间</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl age</span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl age</span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ttl age</span><br><span class="line">(integer) -<span class="number">2</span> # -<span class="number">2</span> 表示key过期，-<span class="number">1</span>表示key未设置过期时间</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get age # 过期的key 会被自动delete</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> name # 查看value的数据类型</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>关于<code>TTL</code>命令</p><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p><ol><li>当前key没有设置过期时间，所以会返回-1.</li><li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ol><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ul><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ul><p>更多命令学习：<a href="https://www.redis.net.cn/order/">https://www.redis.net.cn/order/</a></p><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><p>普通的set、get直接略过。</p><table><thead><tr><th align="left">命令</th><th>描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="left"><code>APPEND key value</code></td><td>向指定的key的value后追加字符串</td><td align="center">127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td></tr><tr><td align="left"><code>DECR/INCR key</code></td><td>将指定key的value数值进行+1/-1(仅对于数字)</td><td align="center">127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td></tr><tr><td align="left"><code>INCRBY/DECRBY key n</code></td><td>按指定的步长对数值进行加减</td><td align="center">127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td></tr><tr><td align="left"><code>INCRBYFLOAT key n</code></td><td>为数值加上浮点型数值</td><td align="center">127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td></tr><tr><td align="left"><code>STRLEN key</code></td><td>获取key保存值的字符串长度</td><td align="center">127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td></tr><tr><td align="left"><code>GETRANGE key start end</code></td><td>按起止位置获取字符串（闭区间，起止位置都取）</td><td align="center">127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td></tr><tr><td align="left"><code>SETRANGE key offset value</code></td><td>用指定的value 替换key中 offset开始的值</td><td align="center">127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td></tr><tr><td align="left"><code>GETSET key value</code></td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td><td align="center">127.0.0.1:6379&gt; GETSET msg test “hello world”</td></tr><tr><td align="left"><code>SETNX key value</code></td><td>仅当key不存在时进行set</td><td align="center">127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td></tr><tr><td align="left"><code>SETEX key seconds value</code></td><td>set 键值对并设置过期时间</td><td align="center">127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td></tr><tr><td align="left"><code>MSET key1 value1 [key2 value2..]</code></td><td>批量set键值对</td><td align="center">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td></tr><tr><td align="left"><code>MSETNX key1 value1 [key2 value2..]</code></td><td>批量设置键值对，仅当参数中所有的key都不存在时执行</td><td align="center">127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td></tr><tr><td align="left"><code>MGET key1 [key2..]</code></td><td>批量获取多个key保存的值</td><td align="center">127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td></tr><tr><td align="left"><code>PSETEX key milliseconds value</code></td><td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td><td align="center"></td></tr><tr><td align="left"><code>getset key value</code></td><td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td><td align="center"></td></tr></tbody></table><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li></ul><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><blockquote><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p></blockquote><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等</p><p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>LPUSH/RPUSH key value1[value2..]</code></td><td>从左边/右边向列表中PUSH值(一个或者多个)。</td></tr></tbody></table><ul><li><p>LRANGE key start end    获取list 起止元素==（索引从左往右 递增）==</p></li><li><p>LPUSHX/RPUSHX key value    向已存在的列名中push值（一个或者多个）</p></li><li><p>LINSERT key BEFORE|AFTER pivot value    在指定列表元素的前/后 插入value</p></li><li><p>LLEN key    查看列表长度</p></li><li><p>LINDEX key index    通过索引获取列表元素</p></li><li><p>LSET key index value    通过索引为元素设值</p></li><li><p>LPOP/RPOP key    从最左边/最右边移除值 并返回</p></li><li><p>RPOPLPUSH source destination    将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</p></li><li><p>LTRIM key start end    通过下标截取指定范围内的列表</p></li><li><p><code>LREM key count value</code>    List中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。</p></li><li><p><code>BLPOP/BRPOP key1[key2] timout</code>    移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p></li><li><p><code>BRPOPLPUSH source destination timeout</code>    和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LPUSH mylist k1 # LPUSH mylist=&gt;&#123;<span class="number">1</span>&#125;</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LPUSH mylist k2 # LPUSH mylist=&gt;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; RPUSH mylist k3 # RPUSH mylist=&gt;&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get mylist # 普通的get是无法获取list值的</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> <span class="number">4</span> # LRANGE 获取起止位置范围内的元素</span><br><span class="line"><span class="number">1</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span> # 获取全部元素</span><br><span class="line"><span class="number">1</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LPUSHX list v1 # list不存在 LPUSHX失败</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LPUSHX list v1 v2  </span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k4&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">5</span>) &quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k4&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;ins_key1&quot;</span><br><span class="line"><span class="number">5</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">6</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LLEN mylist # 查看mylist的长度</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LINDEX mylist <span class="number">3</span> # 获取下标为<span class="number">3</span>的元素</span><br><span class="line">&quot;ins_key1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LINDEX mylist <span class="number">0</span></span><br><span class="line">&quot;k5&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LSET mylist <span class="number">3</span> k6 # 将下标<span class="number">3</span>的元素 <span class="built_in">set</span>值为k6</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k4&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;k6&quot;</span><br><span class="line"><span class="number">5</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">6</span>) &quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LPOP mylist # 左侧(头部)弹出</span><br><span class="line">&quot;k5&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; RPOP mylist # 右侧(尾部)弹出</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k6&quot;</span><br><span class="line"><span class="number">4</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span><br><span class="line">&quot;k1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE newlist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k6&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LTRIM mylist <span class="number">0</span> <span class="number">1</span> # 截取mylist中的 <span class="number">0</span>~<span class="number">1</span>部分</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;k4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k2&quot;</span><br><span class="line"></span><br><span class="line"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line"></span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LREM mylist <span class="number">3</span> k2 # 从头部开始搜索 至多删除<span class="number">3</span>个 k2</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; LREM mylist -<span class="number">2</span> k2 #从尾部开始搜索 至多删除<span class="number">2</span>个 k2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mylist: <span class="title">k2</span>,<span class="title">k2</span>,<span class="title">k2</span>,<span class="title">k4</span>,<span class="title">k2</span>,<span class="title">k2</span></span></span><br><span class="line"><span class="function"><span class="title">newlist</span>: <span class="title">k1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; <span class="title">BLPOP</span> <span class="title">newlist</span> <span class="title">mylist</span> 30 # 从<span class="title">newlist</span>中弹出第一个值，<span class="title">mylist</span>作为候选</span></span><br><span class="line"><span class="function">1) &quot;<span class="title">newlist</span>&quot; # 弹出</span></span><br><span class="line"><span class="function">2) &quot;<span class="title">k1</span>&quot;</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; <span class="title">BLPOP</span> <span class="title">newlist</span> <span class="title">mylist</span> 30</span></span><br><span class="line"><span class="function">1) &quot;<span class="title">mylist</span>&quot; # 由于<span class="title">newlist</span>空了 从<span class="title">mylist</span>中弹出</span></span><br><span class="line"><span class="function">2) &quot;<span class="title">k2</span>&quot;</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; <span class="title">BLPOP</span> <span class="title">newlist</span> 30</span></span><br><span class="line"><span class="function">(30.10<span class="title">s</span>) # 超时了</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; <span class="title">BLPOP</span> <span class="title">newlist</span> 30 # 我们连接另一个客户端向<span class="title">newlist</span>中<span class="title">push</span>了<span class="title">test</span>, 阻塞被解决。</span></span><br><span class="line"><span class="function">1) &quot;<span class="title">newlist</span>&quot;</span></span><br><span class="line"><span class="function">2) &quot;<span class="title">test</span>&quot;</span></span><br><span class="line"><span class="function">(12.54<span class="title">s</span>)</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><blockquote><p>Redis的Set是<strong>string类型</strong>的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><ul><li>HSET key field value    将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</li><li>HMSET key field1 value1 [field2 value2..]    同时将多个 field-value (域-值)对设置到哈希表 key 中。</li><li>HSETNX key field value    只有在字段 field 不存在时，设置哈希表字段的值。</li><li>HEXISTS key field    查看哈希表 key 中，指定的字段是否存在。</li><li>HGET key field value    获取存储在哈希表中指定字段的值</li><li>HMGET key field1 [field2..]    获取所有给定字段的值</li><li>HGETALL key    获取在哈希表key 的所有字段和值</li><li>HKEYS key    获取哈希表key中所有的字段<br>HLEN key    获取哈希表中字段的数量</li><li>HVALS key    获取哈希表中所有值</li><li>HDEL key field1 [field2..]    删除哈希表key中一个/多个field字段</li><li>HINCRBY key field n    为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</li><li>HINCRBYFLOAT key field n    为哈希表 key 中的指定字段的浮点数值加上增量 n。</li><li>HSCAN key cursor [MATCH pattern] [COUNT count]    迭代哈希表中的键值对。</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回<span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HSET studentx age <span class="number">20</span> # 设置studentx的age为<span class="number">20</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HMSET studentx sex <span class="number">1</span> tel <span class="number">15623667886</span> # 设置sex为<span class="number">1</span>，tel为<span class="number">15623667886</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field</span><br><span class="line">(integer) <span class="number">0</span> # 失败</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HSETNX studentx email <span class="number">12345</span>@qq.com</span><br><span class="line">(integer) <span class="number">1</span> # 成功</span><br><span class="line"></span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HEXISTS studentx name # name字段在studentx中是否存在</span><br><span class="line">(integer) <span class="number">1</span> # 存在</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HEXISTS studentx addr</span><br><span class="line">(integer) <span class="number">0</span> # 不存在</span><br><span class="line"></span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HGET studentx name # 获取studentx中name字段的value</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value</span><br><span class="line"><span class="number">1</span>) &quot;gyc&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">20</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">15623667886</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HGETALL studentx # 获取studentx中所有的field及其value</span><br><span class="line"> <span class="number">1</span>) &quot;name&quot;</span><br><span class="line"> <span class="number">2</span>) &quot;gyc&quot;</span><br><span class="line"> <span class="number">3</span>) &quot;age&quot;</span><br><span class="line"> <span class="number">4</span>) &quot;<span class="number">20</span>&quot;</span><br><span class="line"> <span class="number">5</span>) &quot;sex&quot;</span><br><span class="line"> <span class="number">6</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"> <span class="number">7</span>) &quot;tel&quot;</span><br><span class="line"> <span class="number">8</span>) &quot;<span class="number">15623667886</span>&quot;</span><br><span class="line"> <span class="number">9</span>) &quot;email&quot;</span><br><span class="line"><span class="number">10</span>) &quot;<span class="number">12345</span>@qq.com&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HKEYS studentx # 查看studentx中所有的field</span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;age&quot;</span><br><span class="line"><span class="number">3</span>) &quot;sex&quot;</span><br><span class="line"><span class="number">4</span>) &quot;tel&quot;</span><br><span class="line"><span class="number">5</span>) &quot;email&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HLEN studentx # 查看studentx中的字段数量</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HVALS studentx # 查看studentx中所有的value</span><br><span class="line"><span class="number">1</span>) &quot;gyc&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">20</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">15623667886</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;<span class="number">12345</span>@qq.com&quot;</span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HKEYS studentx</span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;age&quot;</span><br><span class="line"><span class="number">3</span>) &quot;email&quot;</span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HINCRBY studentx age <span class="number">1</span> # studentx的age字段数值+<span class="number">1</span></span><br><span class="line">(integer) <span class="number">21</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HINCRBY studentx name <span class="number">1</span> # 非整数字型字段不可用</span><br><span class="line">(error) ERR hash value is <span class="keyword">not</span> an integer</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; HINCRBYFLOAT studentx weight <span class="number">0</span>.<span class="number">6</span> # weight字段增加<span class="number">0</span>.<span class="number">6</span></span><br><span class="line">&quot;<span class="number">90</span>.<span class="number">8</span>&quot;</span><br></pre></td></tr></table></figure><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！<strong>Hash更适合于对象的存储，Sring更加适合字符串存储！</strong></p><h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><ul><li>ZADD key score member1 [score2 member2]    向有序集合添加一个或多个成员，或者更新已存在成员的分数</li><li>ZCARD key    获取有序集合的成员数</li><li>ZCOUNT key min max    计算在有序集合中指定区间score的成员数</li><li>ZINCRBY key n member    有序集合中对指定成员的分数加上增量 n</li><li>ZSCORE key member    返回有序集中，成员的分数值</li><li>ZRANK key member    返回有序集合中指定成员的索引</li><li>ZRANGE key start end    通过索引区间返回有序集合成指定区间内的成员</li><li>ZRANGEBYLEX key min max    通过字典区间返回有序集合的成员</li><li>ZRANGEBYSCORE key min max    通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()==</li><li>ZLEXCOUNT key min max    在有序集合中计算指定字典区间内成员数量</li><li>ZREM key member1 [member2..]    移除有序集合中一个/多个成员</li><li>ZREMRANGEBYLEX key min max    移除有序集合中给定的字典区间的所有成员</li><li>ZREMRANGEBYRANK key start stop    移除有序集合中给定的排名区间的所有成员</li><li>ZREMRANGEBYSCORE key min max    移除有序集合中给定的分数区间的所有成员</li><li>ZREVRANGE key start end    返回有序集中指定区间内的成员，通过索引，分数从高到底</li><li>ZREVRANGEBYSCORRE key max min    返回有序集中指定分数区间内的成员，分数从高到低排序</li><li>ZREVRANGEBYLEX key max min    返回有序集中指定字典区间内的成员，按字典顺序倒序</li><li>ZREVRANK key member    返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li>ZINTERSTORE destination numkeys key1 [key2 ..]    计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</li><li>ZUNIONSTORE destination numkeys key1 [key2..]    计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li><li>ZSCAN key cursor [MATCH pattern] [COUNT count]    迭代有序集合中的元素（包括元素成员和元素分值）</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZADD myzset <span class="number">1</span> m1 <span class="number">2</span> m2 <span class="number">3</span> m3 # 向有序集合myzset中添加成员m1 score=<span class="number">1</span> 以及成员m2 score=<span class="number">2</span>..</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZCARD myzset # 获取有序集合的成员数</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZCOUNT myzset <span class="number">0</span> <span class="number">1</span> # 获取score在 [<span class="number">0</span>,<span class="number">1</span>]区间的成员数量</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZCOUNT myzset <span class="number">0</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZINCRBY myzset <span class="number">5</span> m2 # 将成员m2的score +<span class="number">5</span></span><br><span class="line">&quot;<span class="number">7</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZSCORE myzset m1 # 获取成员m1的score</span><br><span class="line">&quot;<span class="number">1</span>&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZSCORE myzset m2</span><br><span class="line">&quot;<span class="number">7</span>&quot;</span><br><span class="line"></span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANK myzset m2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE myzset <span class="number">0</span> <span class="number">1</span> # 获取索引在 <span class="number">0</span>~<span class="number">1</span>的成员</span><br><span class="line"><span class="number">1</span>) &quot;m1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;m3&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE myzset <span class="number">0</span> -<span class="number">1</span> # 获取全部成员</span><br><span class="line"><span class="number">1</span>) &quot;m1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;m3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;m2&quot;</span><br><span class="line"></span><br><span class="line">#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为<span class="number">0</span></span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYLEX testset - + # 返回所有成员</span><br><span class="line"><span class="number">1</span>) &quot;abc&quot;</span><br><span class="line"><span class="number">2</span>) &quot;add&quot;</span><br><span class="line"><span class="number">3</span>) &quot;amaze&quot;</span><br><span class="line"><span class="number">4</span>) &quot;apple&quot;</span><br><span class="line"><span class="number">5</span>) &quot;back&quot;</span><br><span class="line"><span class="number">6</span>) &quot;java&quot;</span><br><span class="line"><span class="number">7</span>) &quot;redis&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYLEX testset - + LIMIT <span class="number">0</span> <span class="number">3</span> # 分页 按索引显示查询结果的 <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>条记录</span><br><span class="line"><span class="number">1</span>) &quot;abc&quot;</span><br><span class="line"><span class="number">2</span>) &quot;add&quot;</span><br><span class="line"><span class="number">3</span>) &quot;amaze&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYLEX testset - + LIMIT <span class="number">3</span> <span class="number">3</span> # 显示 <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>条记录</span><br><span class="line"><span class="number">1</span>) &quot;apple&quot;</span><br><span class="line"><span class="number">2</span>) &quot;back&quot;</span><br><span class="line"><span class="number">3</span>) &quot;java&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员</span><br><span class="line"><span class="number">1</span>) &quot;abc&quot;</span><br><span class="line"><span class="number">2</span>) &quot;add&quot;</span><br><span class="line"><span class="number">3</span>) &quot;amaze&quot;</span><br><span class="line"><span class="number">4</span>) &quot;apple&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员</span><br><span class="line"><span class="number">1</span>) &quot;apple&quot;</span><br><span class="line"><span class="number">2</span>) &quot;back&quot;</span><br><span class="line"><span class="number">3</span>) &quot;java&quot;</span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE myzset <span class="number">1</span> <span class="number">10</span> # 返回score在 [<span class="number">1</span>,<span class="number">10</span>]之间的的成员</span><br><span class="line"><span class="number">1</span>) &quot;m1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;m3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;m2&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE myzset <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span>) &quot;m1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;m3&quot;</span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZLEXCOUNT testset - +</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREM testset abc # 移除成员abc</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREMRANGEBYRANK testset <span class="number">0</span> <span class="number">1</span> # 移除排名<span class="number">0</span>~<span class="number">1</span>的所有成员</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREMRANGEBYSCORE myzset <span class="number">0</span> <span class="number">3</span> # 移除score在 [<span class="number">0</span>,<span class="number">3</span>]的成员</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"># myzset=&gt; &#123;(m1,<span class="number">1</span>),(m2,<span class="number">2</span>),(m3,<span class="number">3</span>),(m4,<span class="number">4</span>),(m7,<span class="number">7</span>),(m9,<span class="number">9</span>)&#125;</span><br><span class="line"></span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREVRANGE myzset <span class="number">0</span> <span class="number">3</span> # 按score递减排序，然后按索引，返回结果的 <span class="number">0</span>~<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;m9&quot;</span><br><span class="line"><span class="number">2</span>) &quot;m7&quot;</span><br><span class="line"><span class="number">3</span>) &quot;m4&quot;</span><br><span class="line"><span class="number">4</span>) &quot;m3&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREVRANGE myzset <span class="number">2</span> <span class="number">4</span> # 返回排序结果的 索引的<span class="number">2</span>~<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) &quot;m4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;m3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;m2&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREVRANGEBYSCORE myzset <span class="number">6</span> <span class="number">2</span> # 按score递减顺序 返回集合中分数在[<span class="number">2</span>,<span class="number">6</span>]之间的成员</span><br><span class="line"><span class="number">1</span>) &quot;m4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;m3&quot;</span><br><span class="line"><span class="number">3</span>) &quot;m2&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员</span><br><span class="line"><span class="number">1</span>) &quot;java&quot;</span><br><span class="line"><span class="number">2</span>) &quot;back&quot;</span><br><span class="line"><span class="number">3</span>) &quot;apple&quot;</span><br><span class="line"><span class="number">4</span>) &quot;amaze&quot;</span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZREVRANK myzset m2</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mathscore=&gt;&#123;(xm,<span class="number">90</span>),(xh,<span class="number">95</span>),(xg,<span class="number">87</span>)&#125; 小明、小红、小刚的数学成绩</span><br><span class="line"></span><br><span class="line"># enscore=&gt;&#123;(xm,<span class="number">70</span>),(xh,<span class="number">93</span>),(xg,<span class="number">90</span>)&#125; 小明、小红、小刚的英语成绩</span><br><span class="line"></span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZINTERSTORE sumscore <span class="number">2</span> mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE sumscore <span class="number">0</span> -<span class="number">1</span> withscores # 合并后的score是之前集合中所有score的和</span><br><span class="line"><span class="number">1</span>) &quot;xm&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">160</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;xg&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">177</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;xh&quot;</span><br><span class="line"><span class="number">6</span>) &quot;<span class="number">188</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE lowestscore <span class="number">2</span> mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; ZRANGE lowestscore <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) &quot;xm&quot;</span><br><span class="line"><span class="number">2</span>) &quot;<span class="number">70</span>&quot;</span><br><span class="line"><span class="number">3</span>) &quot;xg&quot;</span><br><span class="line"><span class="number">4</span>) &quot;<span class="number">87</span>&quot;</span><br><span class="line"><span class="number">5</span>) &quot;xh&quot;</span><br><span class="line"><span class="number">6</span>) &quot;<span class="number">93</span>&quot;</span><br></pre></td></tr></table></figure><h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><blockquote><p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p></blockquote><ul><li>geoadd key longitud(经度) latitude(纬度) member [..]    将具体经纬度的坐标存入一个有序集合</li><li>geopos key member [member..]    获取集合中的一个/多个成员坐标</li><li>geodist key member1 member2 [unit]    返回两个给定位置之间的距离。默认以米作为单位。</li><li>georadius key longitude latitude radius m|km|mi|ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]    以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</li><li>GEORADIUSBYMEMBER key member radius…    功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</li><li>geohash key member1 [member2..]    返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</li></ul><p><strong>有效经纬度</strong></p><blockquote><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul></blockquote><p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p><strong>关于GEORADIUS的参数</strong></p><blockquote><p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p><p>withcoord:带上坐标</p><p>withdist:带上距离，单位与半径单位相同</p><p>COUNT n : 只显示前n个(按距离递增排序)</p></blockquote><h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型</p></blockquote><p><strong>什么是基数？</strong></p><blockquote><p>数据集中不重复的元素的个数。</p></blockquote><p><strong>应用场景：</strong></p><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><blockquote><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p></blockquote><ul><li>命令    描述</li><li>PFADD key element1 [elememt2..]    添加指定元素到 HyperLogLog 中</li><li>PFCOUNT key [key]    返回给定 HyperLogLog 的基数估算值。</li><li>PFMERGE destkey sourcekey [sourcekey..]    将多个 HyperLogLog 合并为一个 HyperLogLog</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFADD myelemx a b c d e f g h i j k # 添加元素</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> myelemx # hyperloglog底层使用String</span><br><span class="line">string</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFCOUNT myelemx # 估算myelemx的基数</span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFCOUNT myelemy</span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; PFCOUNT myelemz # 估算基数</span><br><span class="line">(integer) <span class="number">17</span></span><br></pre></td></tr></table></figure><p>如果允许容错，那么一定可以使用Hyperloglog !</p><p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p><h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><blockquote><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p></blockquote><p><strong>应用场景</strong></p><p>签到统计、状态统计</p><ul><li>命令    描述</li><li>setbit key offset value    为指定key的offset位设置值</li><li>getbit key offset    获取offset位的值</li><li>bitcount key [start end]    统计字符串被设置为1的bit数，也可以指定统计范围按字节</li><li>bitop operration destkey key[key..]    对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</li><li>BITPOS key bit [start] [end]    返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit sign <span class="number">0</span> <span class="number">1</span> # 设置sign的第<span class="number">0</span>位为 <span class="number">1</span> </span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit sign <span class="number">2</span> <span class="number">1</span> # 设置sign的第<span class="number">2</span>位为 <span class="number">1</span>  不设置默认 是<span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit sign <span class="number">3</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; setbit sign <span class="number">5</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getbit sign <span class="number">2</span> # 获取第<span class="number">2</span>位的数值</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getbit sign <span class="number">3</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; getbit sign <span class="number">4</span> # 未设置默认是<span class="number">0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; BITCOUNT sign # 统计sign中为<span class="number">1</span>的位数</span><br><span class="line">(integer) <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><blockquote><p>Redis事务本质：一组命令的集合。</p><p>—————– 队列 set set set 执行 ——————-</p><p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性</li><li>顺序性</li><li>排他性</li></ul><hr><ol><li>Redis事务没有隔离级别的概念</li><li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li></ol></blockquote><h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ul><li>开启事务（<code>multi</code>）</li><li>命令入队</li><li>执行事务（<code>exec</code>）</li></ul><p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi # 开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k1 v1 # 命令入队</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k2 v2 # ..</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; exec # 事务执行</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">4</span>) OK</span><br><span class="line"><span class="number">5</span>) <span class="number">1</span>) &quot;k3&quot;</span><br><span class="line">   <span class="number">2</span>) &quot;k2&quot;</span><br><span class="line">   <span class="number">3</span>) &quot;k1&quot;</span><br></pre></td></tr></table></figure><p><strong>取消事务(<code>discurd</code>)</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; DISCARD # 放弃事务</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; EXEC </span><br><span class="line">(error) ERR EXEC without MULTI # 当前未开启事务</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get k1 # 被放弃事务中命令并未执行</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><blockquote><p>代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; error k1 <span class="comment"># 这是一条语法错误命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `error`, with args beginning with: `k1`, <span class="comment"># 会报错但是不影响后续命令入队 </span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. <span class="comment"># 执行报错</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 </span><br><span class="line">(nil) <span class="comment"># 其他命令并没有被执行</span></span><br></pre></td></tr></table></figure><blockquote><p>代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** &gt;&gt;&gt; 所以不保证事务原子性</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1 <span class="comment"># 这条命令逻辑错误（对字符串进行增量）</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 运行时报错</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span> <span class="comment"># 其他命令正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</span></span><br><span class="line"><span class="comment"># 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span></span><br></pre></td></tr></table></figure><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p><blockquote><p>正常执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 设置余额:100</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> use 0 <span class="comment"># 支出使用:0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money (上锁)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 监视值没有被中途修改，事务正常执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><blockquote><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p></blockquote><p>我们启动另外一个客户端模拟插队线程。</p><p>线程1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># money上锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="comment"># 此时事务并没有执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模拟线程插队，线程2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 <span class="comment"># 修改了线程一中监视的money</span></span><br><span class="line">(<span class="built_in">integer</span>) 600</span><br></pre></td></tr></table></figure><p>回到线程1，执行事务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC <span class="comment"># 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span></span><br><span class="line">(nil) <span class="comment"># 没有结果，说明事务执行失败</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money <span class="comment"># 线程2 修改生效</span></span><br><span class="line"><span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get use <span class="comment"># 线程1事务执行失败，数值没有被修改</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解锁获取最新值，然后再加锁进行事务。</p><p><code>unwatch</code>进行解锁。</p><p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p><h2 id="六、Jedis"><a href="#六、Jedis" class="headerlink" title="六、Jedis"></a>六、Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jredis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.编码测试</p><ul><li><p>连接数据库</p></li><li><p>修改redis的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/bin/myconfig/redis.conf</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>…………………………………..</p><p>未完</p><h2 id="七、SpringBoot整合"><a href="#七、SpringBoot整合" class="headerlink" title="七、SpringBoot整合"></a>七、SpringBoot整合</h2><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p><blockquote><p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p></blockquote><p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p><p><img src="/img/img3.png"></p><p>那么就一定还存在一个RedisProperties类</p><p><img src="/img/img4.png"></p><p>之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。</p><p>先看Jedis:</p><p><img src="/img/img5.png"></p><p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p><p>然后再看Lettuce：</p><p><img src="/img/img6.png"></p><p>完美生效。</p><p>现在我们回到RedisAutoConfiguratio</p><p><img src="/img/img7.png"></p><p>只有两个简单的Bean</p><ul><li><strong>RedisTemplate</strong></li><li><strong>StringRedisTemplate</strong></li></ul><p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p><p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p><p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p><p><img src="/img/img8.png"></p><p>这是一些基本的配置属性。</p><p><img src="/img/img9.png"></p><p>还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。</p><p><img src="/img/img10.png"></p><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">39.99.xxx.xx</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure><p>使用RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForHah</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line">        <span class="comment">//connection.flushDb();</span></span><br><span class="line">        <span class="comment">//connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><p><strong>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：</strong></p><p><img src="/img/img11.png"></p><p> 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p><p>我们转到看那个默认的RedisTemplate内部什么样子：</p><p><img src="/img/img12.png"></p><p>在最开始就能看到几个关于序列化的参数。</p><p>默认的序列化器是采用JDK序列化器</p><p>而默认的RedisTemplate中的所有序列化器都是使用这个序列化器：</p><p>后续我们定制RedisTemplate就可以对其进行修改。</p><p><code>RedisSerializer</code>提供了多种序列化方案：</p><ul><li>直接调用RedisSerializer的静态方法来返回序列化器，然后set</li></ul><p><img src="/img/img13.png"></p><p><strong>定制RedisTemplate的模板：</strong></p><p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p><p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 将template 泛型设置为 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        <span class="comment">// 连接工厂，不必修改</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 序列化设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// key、hash的key 采用 String序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// value、hash的value 采用 Jackson 序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</p><h2 id="八、自定义Redis工具类"><a href="#八、自定义Redis工具类" class="headerlink" title="八、自定义Redis工具类"></a>八、自定义Redis工具类</h2><p>使用RedisTemplate需要频繁调用<code>.opForxxx</code>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p><p>工具类参考博客：</p><p><a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html">https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html</a></p><p><a href="https://www.cnblogs.com/zhzhlong/p/11434284.html">https://www.cnblogs.com/zhzhlong/p/11434284.html</a></p><h2 id="九、Redis-conf"><a href="#九、Redis-conf" class="headerlink" title="九、Redis.conf"></a>九、Redis.conf</h2><blockquote><p>容量单位不区分大小写，G和GB有区别</p></blockquote><p><img src="/img/img14.png"></p><p>可以使用 include 组合多个配置问题</p><p><img src="/img/img15.png"></p><p>网络配置</p><p><img src="/img/img16.png"></p><p>日志输出级别</p><p><img src="/img/img17.png"></p><p>日志输出文件</p><p><img src="/img/img18.png"></p><blockquote><p>持久化规则</p></blockquote><p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><p><img src="/img/img19.png"></p><p>Security模块中进行密码设置</p><p><img src="/img/img20.png"></p><p>客户端连接相关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  最大客户端数量</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存限制</span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到限制值的处理策略</span></span><br></pre></td></tr></table></figure><p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p><p><strong>设置方式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> maxmemory-policy volatile-lru </span><br></pre></td></tr></table></figure><h2 id="十、持久化—RDB"><a href="#十、持久化—RDB" class="headerlink" title="十、持久化—RDB"></a>十、持久化—RDB</h2><p>RDB：Redis Databases</p><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><hr><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p><p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr><p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p><code>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益</code>(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><p><img src="/img/img21.jpg"></p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><hr><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p><code>flushall</code> 命令也会触发持久化 ；</p><h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件 ；</p><p>满足配置条件中的触发条件 ；</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p></blockquote><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p><p><img src="/img/img22.jpg"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="十一、持久化AOF"><a href="#十一、持久化AOF" class="headerlink" title="十一、持久化AOF"></a>十一、持久化AOF</h2><p><strong>Append Only File</strong></p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p><h2 id="十二、RDB和AOP选择"><a href="#十二、RDB和AOP选择" class="headerlink" title="十二、RDB和AOP选择"></a>十二、RDB和AOP选择</h2><h3 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h3><table><thead><tr><th>RDB</th><th>AOF</th><th></th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h2 id="十三、Redis发布与订阅"><a href="#十三、Redis发布与订阅" class="headerlink" title="十三、Redis发布与订阅"></a>十三、Redis发布与订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="/img/img23.png"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/img/img24.png"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr></tbody></table><p>PUBSUB subcommand [argument[argument]]    查看订阅与发布系统状态。<br>PUBLISH channel message    向指定频道发布消息<br>SUBSCRIBE channel [channel..]    订阅给定的一个或多个频道。<br>SUBSCRIBE channel [channel..]    退订一个或多个频道</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">------------订阅端----------------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit) <span class="comment"># 等待接收消息</span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 订阅成功的消息</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello world&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello world&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello i am sakura&quot;</span></span><br><span class="line"></span><br><span class="line">--------------消息发布端-------------------</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello world&quot;</span> <span class="comment"># 发布消息到sakura频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello i am sakura&quot;</span> <span class="comment"># 发布消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">-----------------查看活跃的频道------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) <span class="string">&quot;sakura&quot;</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src="/img/img25.png"></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h2 id="四、Redis主从复制"><a href="#四、Redis主从复制" class="headerlink" title="四、Redis主从复制"></a>四、Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</p></li><li><p>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</p></li><li><p>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</p></li><li><p>高可用基石：主从复制还是哨兵和集群能够实施的基础。</p></li></ol><h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p><p>查看当前库的信息：<code>info replication</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p><ul><li>端口号</li><li>pid文件名</li><li>日志文件名</li><li>rdb文件名</li></ul><p>启动单机多服务集群：</p><p><img src="/img/img26.png"></p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p>==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p><p>我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。</p><p><img src="/img/img27.png"></p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sakura&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></blockquote><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p><h2 id="十五、哨兵模式"><a href="#十五、哨兵模式" class="headerlink" title="十五、哨兵模式"></a>十五、哨兵模式</h2><p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p><h2 id="十六、缓存穿透与雪崩"><a href="#十六、缓存穿透与雪崩" class="headerlink" title="十六、缓存穿透与雪崩"></a>十六、缓存穿透与雪崩</h2><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><p>。。。。。。。。</p><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote><p>概念</p></blockquote><p>相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><p>比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p><p>。。。。。。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p>。。。。。。。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Nosql概述&quot;&gt;&lt;a href=&quot;#一、Nosql概述&quot; class=&quot;headerlink&quot; title=&quot;一、Nosql概述&quot;&gt;&lt;/a&gt;一、Nosql概述&lt;/h2&gt;&lt;h3 id=&quot;为什么使用Nosql&quot;&gt;&lt;a href=&quot;#为什么使用Nosql&quot; cla</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>TV第二轮考核学习笔记</title>
    <link href="http://example.com/2021/10/01/TV%E7%AC%AC%E4%BA%8C%E8%BD%AE%E8%80%83%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/10/01/TV%E7%AC%AC%E4%BA%8C%E8%BD%AE%E8%80%83%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-30T17:18:20.000Z</published>
    <updated>2022-11-03T09:09:18.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TV第二轮考核学习笔记"><a href="#TV第二轮考核学习笔记" class="headerlink" title="TV第二轮考核学习笔记"></a>TV第二轮考核学习笔记</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="OOP七大原则"><a href="#OOP七大原则" class="headerlink" title="OOP七大原则"></a>OOP七大原则</h3><p><strong>OCP（Open-Closed Principle），开放封闭原则</strong>：软件实体应该扩展开放、修改封闭。<br>实现：合理划分构件，一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里；一种可变性不应当与另一个可变性混合在一起。</p><p><strong>DIP(Dependency Inversion Principle)，依赖倒置原则：</strong>摆脱面向过程编程思想中高层模块依赖于低层实现，抽象依赖于具体细节。OOP中要做到的是，高层模块不依赖于低层模块实现，二者都依赖于抽象；抽象不依赖于具体实现细节，细节依赖于抽象。<br>实现：应该通过抽象耦合的方式，使具体类最大可能的仅与其抽象类（接口）发生耦合；程序在需要引用一个对象时,应当尽可能的使用抽象类型作为变量的静态类型,这就是针对接口编程的含义。</p><p><strong>LSP(Liskov Substitution Principle)，Liskov替换原则：</strong>继承思想的基础, 即子类能替代父类使用。“只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才真正被复用，而衍生类也才能够在基类的基础上增加新的行为。”</p><p><strong>ISP（Interface Insolation Principle），接口隔离原则：</strong>客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上<strong>，</strong>不要引入无关因素，避免接口污染。<br>实现：一个类对另外一个类的依赖性应当是建立在最小的接口上的。<strong>使用多个专门的接口比使用单一的总接口要好。</strong></p><p><strong>SRP(Single Resposibility Principle)，单一职责原则：</strong>就一个类而言，接口职责单一，应该仅有一个引起它变化的原因。 如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会抑止这个类完成其他职责的能力。</p><p><strong>CARP（Composite/Aggregate Reuse Principle），合成/聚合复用原则：</strong>设计模式告诉我们对象委托优于类继承，从UML的角度讲，就是关联关系优于继承关系。尽量使用合成/聚合、尽量不使用继承。<br>实现：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，以整合其功能。</p><p><strong>LoD(Law Of Demeter or Principle of Least Knowledge)，迪米特原则或最少知识原则：</strong>就是说一个对象应当对其他对象尽可能少的了解，依赖越少越好。即只直接与朋友通信，或者通过朋友与陌生人通信。</p><h3 id="单例模式-2021-5-2"><a href="#单例模式-2021-5-2" class="headerlink" title="单例模式 2021/5/2"></a>单例模式 2021/5/2</h3><p>一个类只有一个实例</p><p><strong>优点</strong>：</p><ul><li>在内存中只有一个对象，节省内存空间；</li><li>避免频繁的创建销毁对象，可以提高性能；</li><li>避免对共享资源的多重占用，简化访问；</li><li>为整个系统提供一个全局访问点。</li></ul><p><strong>缺点</strong>：</p><ul><li> 不适用于变化频繁的对象；</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li><li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失</li></ul><h3 id="工厂模式-2020-5-2"><a href="#工厂模式-2020-5-2" class="headerlink" title="工厂模式 2020/5/2"></a>工厂模式 2020/5/2</h3><p>实现创建者和调用者分离</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul><li><p>Parameter()：只有getParameter()，没有setParameter()</p></li><li><p>getAttribute()  ： setAttribute()和getAttribute()成对使用</p></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li></li></ul><h3 id="数据库命名规范-2021-5-8"><a href="#数据库命名规范-2021-5-8" class="headerlink" title="数据库命名规范 2021/5/8"></a>数据库命名规范 2021/5/8</h3><p><a href="https://blog.csdn.net/qq_36390239/article/details/80373315">数据库表及字段命名规范（一）_kler的博客-CSDN博客_数据库字段名命名规则</a></p><h3 id="Servlet-2021-5-26"><a href="#Servlet-2021-5-26" class="headerlink" title="Servlet 2021/5/26"></a>Servlet 2021/5/26</h3><h4 id="servlet是单例的吗"><a href="#servlet是单例的吗" class="headerlink" title="servlet是单例的吗?"></a>servlet是单例的吗?</h4><h5 id="Setvlet的加载方式有以下几种"><a href="#Setvlet的加载方式有以下几种" class="headerlink" title="Setvlet的加载方式有以下几种"></a><strong>Setvlet的加载方式有以下几种</strong></h5><ul><li>通过web.xml配置文件加载</li><li>通过注解加载</li><li>通过ServletContext.addServlet()方法加载</li></ul><h5 id="通过web-xml配置文件加载"><a href="#通过web-xml配置文件加载" class="headerlink" title="通过web.xml配置文件加载"></a><strong>通过web.xml配置文件加载</strong></h5><p>这种加载方式是可以只传多例的, web.xml里面配置的是Servlet的类名, 同一个Servlet类名可能对应不同的地址映射</p><h5 id="通过注解加载"><a href="#通过注解加载" class="headerlink" title="通过注解加载"></a><strong>通过注解加载</strong></h5><p>注解加载时默认是单例的, web容器启动的时候如果扫描到某个类上面有WebServlet注解, 那么就会创建该类对应的实例, 并将实例加载到容器中</p><h5 id="通过ServletContext-addServlet-方法加载"><a href="#通过ServletContext-addServlet-方法加载" class="headerlink" title="通过ServletContext.addServlet()方法加载"></a><strong>通过ServletContext.addServlet()方法加载</strong></h5><p>对于这种方法来说, 主要看在使用的时候是否创建了多个Servlet实例, 如果对于同一个Servlet类, 创建了多个实例, 并调用了ServletContext.addServlet()方法, 那么这里就是多例, 如果针对一个Servlet类, 只创建一个实例, 那么就是单例</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>Servlet是可以支持多例的, 根据Servlet的加载方式不同可以有不同的支持方式</p><h3 id="Servlet-Context2020-5-2"><a href="#Servlet-Context2020-5-2" class="headerlink" title="Servlet Context2020/5/2"></a>Servlet Context2020/5/2</h3><p>​        上下文即ServletContext,是一个全局的储存信息的空间，服务器启动，其就存在，服务器关闭，其才释放。所有用户共用一个ServletContext。所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。如，做一个购物类的网站，要从数据库中提取物品信息，如果用session保存这些物品信息，每个用户都访问一便数据库，效率就太低了；所以要用来Servlet上下文来保存，在服务器开始时，就访问数据库，将物品信息存入Servlet上下文中，这样，每个用户只用从上下文中读入物品信息就行了。</p><h4 id="request-getServletContext-getRealPath-？"><a href="#request-getServletContext-getRealPath-？" class="headerlink" title="request.getServletContext().getRealPath  ？"></a>request.getServletContext().getRealPath  ？</h4><h4 id="Realpath-2021-5-2"><a href="#Realpath-2021-5-2" class="headerlink" title="Realpath 2021/5/2"></a>Realpath 2021/5/2</h4><h3 id="SRC文件会被整合进WEB-INF下的classes目录下"><a href="#SRC文件会被整合进WEB-INF下的classes目录下" class="headerlink" title="SRC文件会被整合进WEB-INF下的classes目录下"></a>SRC文件会被整合进WEB-INF下的classes目录下</h3><p><img src="/2021/10/01/TV%E7%AC%AC%E4%BA%8C%E8%BD%AE%E8%80%83%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image%5Crealpath.png"></p><h3 id="JQuery-2021-5-3"><a href="#JQuery-2021-5-3" class="headerlink" title="JQuery 2021/5/3"></a>JQuery 2021/5/3</h3><h3 id="AJAX-2021-5-3"><a href="#AJAX-2021-5-3" class="headerlink" title="AJAX 2021/5/3"></a>AJAX 2021/5/3</h3><h3 id="JSON-2021-5-3"><a href="#JSON-2021-5-3" class="headerlink" title="JSON 2021/5/3"></a>JSON 2021/5/3</h3><h3 id="统一封装Result-Model"><a href="#统一封装Result-Model" class="headerlink" title="统一封装Result Model"></a>统一封装Result Model</h3><h4 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h4><p><a href="https://blog.csdn.net/m0_38043362/article/details/79696296">Java封装统一的Result Model_流连是谁的博客-CSDN博客</a></p><h3 id="请求转发器-2021-5-9"><a href="#请求转发器-2021-5-9" class="headerlink" title="请求转发器 2021/5/9"></a>请求转发器 2021/5/9</h3><h4 id="参考博客：-1"><a href="#参考博客：-1" class="headerlink" title="参考博客："></a>参考博客：</h4><p><a href="https://blog.csdn.net/justloveyou_/article/details/72783008">Map 综述（三）：彻头彻尾理解 ConcurrentHashMap_Rico’s Blogs-CSDN博客_concurrenthashmap</a></p><h3 id="uri-amp-amp-url"><a href="#uri-amp-amp-url" class="headerlink" title="uri &amp;&amp; url"></a>uri &amp;&amp; url</h3><h3 id="javaweb-文件上传-2021-5-22"><a href="#javaweb-文件上传-2021-5-22" class="headerlink" title="javaweb 文件上传 2021/5/22"></a>javaweb 文件上传 2021/5/22</h3><h4 id="request-getPart-；"><a href="#request-getPart-；" class="headerlink" title="request.getPart()；"></a>request.getPart()；</h4><p>request.getParts()获取上传文件<br>request.getParts(“属性名”)用于获取使用<strong>multipart/form-data</strong>格式传递的http请求的请求体，通常用于获取上传文件</p><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p><a href="https://www.jianshu.com/p/e984c3619019">FormData使用方法详解 - 简书 (jianshu.com)</a></p><h3 id="IOC-2021-5-24"><a href="#IOC-2021-5-24" class="headerlink" title="IOC 2021/5/24"></a>IOC 2021/5/24</h3><p><strong>1.什么是IOC（Inversion of Control 控制反转）？</strong></p><p>IoC不是一种技术，只是<strong>一种思想</strong>，一个重要的面向对象编程的法则，它能指导我们如何设计出<strong>松耦合、更优良</strong>的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，<strong>把创建和查找依赖对象的控制权交给了容器</strong>，<strong>由容器进行注入组合对象</strong>，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p><p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“<strong>别找我们，我们找你</strong>”；即由<strong>IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</strong></p><p><strong>2.什么是DI(Dependency Injection 依赖注入)?</strong></p><p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p><strong>3.IOC和DI什么关系？</strong></p><p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>控制反转 即控制权移交给容器 </p><p><strong>4.什么是依赖？</strong></p><p>传统应用程序设计中所说的依赖一般指“类之间的关系”，那先让我们复习一下类之间的关系：</p><p><strong>泛化：</strong>表示类与类之间的继承关系、接口与接口之间的继承关系；</p><p><strong>实现：</strong>表示类对接口的实现；</p><p><strong>依赖：</strong>当类与类之间有使用关系时就属于依赖关系，不同于关联关系，依赖不具有“拥有关系”，而是一种“相识关系”，只在某个特定地方（比如某个方法体内）才有关系。</p><p><strong>关联：</strong>表示类与类或类与接口之间的依赖关系，表现为“拥有关系”；具体到代码可以用实例变量来表示；</p><p><strong>聚合：</strong>属于是关联的特殊情况，体现部分-整体关系，是一种弱拥有关系；整体和部分可以有不一样的生命周期；是一种弱关联；</p><p><strong>组合：</strong>属于是关联的特殊情况，也体现了体现部分-整体关系，是一种强“拥有关系”；整体与部分有相同的生命周期，是一种强关联；</p><p>Spring IoC容器的依赖有两层含义：Bean依赖容器和容器注入Bean的依赖资源：</p><p><strong>Bean依赖容器：</strong>也就是说Bean要依赖于容器，这里的依赖是指容器负责创建Bean并管理Bean的生命周期，正是由于由容器来控制创建Bean并注入依赖，也就是控制权被反转了，这也正是IoC名字的由来，此处的有依赖是指Bean和容器之间的依赖关系。</p><p><strong>容器注入Bean的依赖资源</strong>：容器负责注入Bean的依赖资源，依赖资源可以是Bean、外部文件、常量数据等，在Java中都反映为对象，并且由容器负责组装Bean之间的依赖关系，此处的依赖是指Bean之间的依赖关系，可以认为是传统类与类之间的“关联”、“聚合”、“组合”关系。</p><p><strong>5.依赖注入的好处？</strong></p><p><strong>动态替换Bean依赖对象，程序更灵活</strong>：替换Bean依赖对象，无需修改源文件：应用依赖注入后，由于可以采用配置文件方式实现，从而能随时动态的替换Bean的依赖对象，无需修改java源文件；</p><p><strong>更好实践面向接口编程，代码更清晰：</strong>在Bean中只需指定依赖对象的接口，接口定义依赖对象完成的功能，通过容器注入依赖实现；</p><p><strong>更好实践优先使用对象组合，而不是类继承：</strong>因为IoC容器采用注入依赖，也就是组合对象，从而更好的实践对象组合。</p><ul><li><p>采用对象组合，Bean的功能可能由几个依赖Bean的功能组合而成，其Bean本身可能只提供少许功能或根本无任何功能，全部委托给依赖Bean，对象组合具有动态性，能更方便的替换掉依赖Bean，从而改变Bean功能；</p></li><li><p>而如果采用类继承，Bean没有依赖Bean，而是采用继承方式添加新功能，，而且功能是在编译时就确定了，不具有动态性，而且采用类继承导致Bean与子Bean之间高度耦合，难以复用。</p><p><strong>增加Bean可复用性</strong>：依赖于对象组合，Bean更可复用且复用更简单；</p><p><strong>降低Bean之间耦合</strong>：由于我们完全采用面向接口编程，在代码中没有直接引用Bean依赖实现，全部引用接口，而且不会出现显示的创建依赖对象代码，而且这些依赖是由容器来注入，很容易替换依赖实现类，从而降低Bean与依赖之间耦合；</p><p><strong>代码结构更清晰：</strong>要应用依赖注入，代码结构要按照规约方式进行书写，从而更好的应用一些最佳实践，因此代码结构更清晰。</p></li></ul><p>从以上我们可以看出，其实依赖注入只是一种装配对象的手段，设计的类结构才是基础，如果设计的类结构不支持依赖注入，Spring IoC容器也注入不了任何东西，从而从根本上说<strong>“如何设计好类结构才是关键，依赖注入只是一种装配对象手段”</strong></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h3 id="MultipartConfig"><a href="#MultipartConfig" class="headerlink" title="@MultipartConfig"></a>@MultipartConfig</h3><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h3 id="Throwable-和Exception"><a href="#Throwable-和Exception" class="headerlink" title="Throwable 和Exception"></a>Throwable 和Exception</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="lambda-2021-5-8d"><a href="#lambda-2021-5-8d" class="headerlink" title="lambda 2021/5/8d"></a>lambda 2021/5/8d</h3><p>源代码中定义的lambda函数，在编译后，编译期会生成一个静态方法，该方法内容和lambda函数的内容完全一致。</p><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客:"></a>参考博客:</h4><p><a href="https://blog.csdn.net/tonywu1992/article/details/83419448">【细谈Java并发】谈谈LinkedBlockingQueue_颤抖吧腿子-CSDN博客_linkedblockingqueue</a></p><p><a href="https://benjaminwhx.com/2018/05/11/[%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91]%E8%B0%88%E8%B0%88LinkedBlockingQueue/">【细谈Java并发】谈谈LinkedBlockingQueue - 蹲厕所的熊 (benjaminwhx.com)</a></p><p><a href="https://benjaminwhx.com/2018/05/05/%E8%AF%B4%E8%AF%B4%E9%98%9F%E5%88%97Queue/">说说队列Queue - 蹲厕所的熊 (benjaminwhx.com)</a></p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue不同于ArrayBlockingQueue，它如果不指定容量，默认为<code>Integer.MAX_VALUE</code>，也就是无界队列。所以为了避免队列过大造成机器负载或者内存爆满的情况出现，我们在使用的时候建议手动传一个队列的大小</p><h4 id="为什么使用LinkedBlockingQueue"><a href="#为什么使用LinkedBlockingQueue" class="headerlink" title="为什么使用LinkedBlockingQueue"></a>为什么使用LinkedBlockingQueue</h4><p>​        每个添加到LinkedBlockingQueue队列中的数据都将被封装成Node节点，添加的链表队列中，其中head和last分别指向队列的头结点和尾结点。与<strong>ArrayBlockingQueue不同的是，LinkedBlockingQueue内部分别使用了takeLock 和 putLock 对并发进行控制，也就是说，添加和删除操作并不是互斥操作</strong>，可以同时进行，这样也就可以大大提高吞吐量。</p><p>​        这里如果<strong>不指定队列的容量大小，也就是使用默认的Integer.MAX_VALUE，如果存在添加速度大于删除速度时候，有可能会内存溢出</strong>，这点在使用前希望慎重考虑</p><p>LinkedBlockingQueue对<strong>每一个lock锁都提供了一个Condition用来挂起和唤醒其他线程</strong></p><p>​        两者的实现队列添加或移除的锁不一样，<strong>ArrayBlockingQueue实现的队列中的锁是没有分离</strong>的，即添加操作和移除操作采用的同一个ReenterLock锁，而LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来<strong>提高整个队列的并发性能</strong></p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认大小为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的构造函数和最后一个构造函数创建的队列大小都为Integer.MAX_VALUE，只有第二个构造函数用户可以指定队列的大小。第二个构造函数最后初始化了last和head节点，让它们都指向了一个元素为null的节点。</p><h5 id="入队方法"><a href="#入队方法" class="headerlink" title="入队方法"></a>入队方法</h5><p>LinkedBlockingQueue提供了多种入队操作的实现来满足不同情况下的需求，入队操作有如下几种：</p><ul><li>void put(E e)；</li><li>boolean offer(E e)；</li><li><strong>boolean offer(E e, long timeout, TimeUnit unit)。</strong></li></ul><h5 id="put-E-e"><a href="#put-E-e" class="headerlink" title="put(E e)"></a>put(E e)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取锁中断</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否已满，如果已满阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把node放入队列中</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 再次判断队列是否有可用空间，如果有唤醒下一个线程进行添加操作</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一条数据，唤醒消费线程进行消费</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结put方法来看，它总共做了以下情况的考虑：</p><ul><li>队列已满，阻塞等待。</li><li>队列未满，创建一个node节点放入队列中，如果放完以后队<strong>列还有剩余空间</strong>，<strong>继续唤醒下一个添加线程进行添加</strong>。如果放之前队列中没有元素，放完以后要唤醒消费线程进行消费。</li></ul><h5 id="offer-E-e-long-timeout-TimeUnit-unit"><a href="#offer-E-e-long-timeout-TimeUnit-unit" class="headerlink" title="offer(E e, long timeout, TimeUnit unit)"></a>offer(E e, long timeout, TimeUnit unit)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待超时时间nanos，超时时间到了返回false</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法只是对offer方法进行了阻塞超时处理，使用了Condition的awaitNanos来进行超时等待，这里为什么要用while循环？因为awaitNanos方法是可中断的，为了防止在等待过程中线程被中断，这里使用while循环进行等待过程中中断的处理，继续等待剩下需等待的时间</p><h5 id="出队方法"><a href="#出队方法" class="headerlink" title="出队方法"></a>出队方法</h5><p>入队列的方法说完后，我们来说说出队列的方法。LinkedBlockingQueue提供了多种出队操作的实现来满足不同情况下的需求，如下：</p><ul><li>E take();</li><li>E poll();</li><li>E poll(long timeout, TimeUnit unit);</li></ul><h5 id="获取方法-take"><a href="#获取方法-take" class="headerlink" title="获取方法 take()"></a>获取方法 take()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 队列中还有元素，唤醒下一个消费线程进行消费</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除元素之前队列是满的，唤醒生产线程进行添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>take方法看起来就是put方法的逆向操作，它总共做了以下情况的考虑：</p><ul><li>队列为空，阻塞等待。</li><li>队列不为空，从队首获取并移除一个元素，如果消费后还有元素在队列中，继续唤醒下一个消费线程进行元素移除。如果放之前队列是满元素的情况，移除完后要唤醒生产线程进行添加元素。</li></ul><h5 id="删除元素方法"><a href="#删除元素方法" class="headerlink" title="删除元素方法"></a>删除元素方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 两个lock全部上锁</span></span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从head开始遍历元素，直到最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="keyword">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="comment">// 如果找到相等的元素，调用unlink方法删除元素</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 两个lock全部解锁</span></span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为remove方法使用两个锁全部上锁，所以其他操作都需要等待它完成，而该方法需要从head节点遍历到尾节点，所以时间复杂度为O(n)。我们来看看unlink方法。</p><h3 id="静态方法引用与实例方法引用"><a href="#静态方法引用与实例方法引用" class="headerlink" title="静态方法引用与实例方法引用"></a>静态方法引用与实例方法引用</h3><h5 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h5><p><a href="https://www.cnblogs.com/pinlantu/p/10434130.html">Java开发笔记（六十四）静态方法引用和实例方法引用 </a></p><h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>这种[方法引用]或者说[双冒号运算]对应的参数类型是Function&lt;T,R&gt; T表示传入类型，R表示返回类型。比如表达式User.getAge(); 传入参数是User，返回值是User.getAge()，那么方法引用User::getAge就对应着Function&lt;User,Integer&gt;类型。</p><h3 id="Funtion-lt-T-R-gt-202-5-8"><a href="#Funtion-lt-T-R-gt-202-5-8" class="headerlink" title="Funtion&lt;T,R&gt; 202/5/8"></a>Funtion&lt;T,R&gt; 202/5/8</h3><p><strong>Function &lt;T，R&gt;<strong>接口是</strong>java.util.function</strong>包中的函数接口。此接口需要一个参数作为输入并生成结果。<strong>Function &lt;T，R&gt;<strong>接口可用作</strong>lambda</strong> <strong>表达式</strong>或<strong>方法****引用</strong>的分配目标。它包含一个抽象方法：<strong>apply()<strong>，两个默认方法：</strong>andThen()<strong>和</strong>compose()</strong> 以及一个静态方法：**identity()**。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空-20218-5-2"><a href="#判空-20218-5-2" class="headerlink" title="判空 20218/5/2"></a>判空 20218/5/2</h3><h4 id="Objects-requireNonNull"><a href="#Objects-requireNonNull" class="headerlink" title="Objects.requireNonNull()"></a>Objects.requireNonNull()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj, String message)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(message);</span><br><span class="line">       <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        说直白一点Objects.requireNonNull就是一个jdk提供的快速判断是否为null的工具，它的思想是快速失败，提前失败，而不是当程序运行时才失败，这或许也是运行时异常不用显式捕获的原因吧，所以要尽量提前快速失败，而不要当程序运行到中途时。</p><h4 id="使用Optional优化判空操作"><a href="#使用Optional优化判空操作" class="headerlink" title="使用Optional优化判空操作"></a>使用<code>Optional</code>优化判空操作</h4><p>[<a href="https://blog.csdn.net/yangxiao_hui/article/details/89853413]">https://blog.csdn.net/yangxiao_hui/article/details/89853413]</a>: </p><p>例子：</p><p>以前写法</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">(User user)</span>  <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(user.getAddress()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Address address = user.getAddress();</span><br><span class="line">                <span class="keyword">if</span>(address.getCity()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> address.getCity();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Excpetion(<span class="string">&quot;取值错误&quot;</span>); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JAVA8写法</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(user)</span><br><span class="line">                   .map(u-&gt; u.getAddress())</span><br><span class="line">                   .map(a-&gt;a.getCity())</span><br><span class="line">                   .orElseThrow(()-&gt;<span class="keyword">new</span> Exception(<span class="string">&quot;取指错误&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例二</p><p>比如，在主程序中</p><p>以前写法</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    dosomething(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA8写法</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Optional.ofNullable(user)</span><br><span class="line">    .ifPresent(u-&gt;&#123;</span><br><span class="line">        dosomething(u);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例三</p><p>以前写法</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        String name = user.getName();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhangsan&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java8写法</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(user)</span><br><span class="line">                   .filter(u-&gt;<span class="string">&quot;zhangsan&quot;</span>.equals(u.getName()))</span><br><span class="line">                   .orElseGet(()-&gt; &#123;</span><br><span class="line">                        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">                        user1.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> user1;</span><br><span class="line">                   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK8时间新特性-2021-5-24"><a href="#JDK8时间新特性-2021-5-24" class="headerlink" title="JDK8时间新特性 2021/5/24"></a>JDK8时间新特性 2021/5/24</h3><h3 id="Stream流操作集合-2021-5-8"><a href="#Stream流操作集合-2021-5-8" class="headerlink" title="Stream流操作集合 2021/5/8"></a>Stream流操作集合 2021/5/8</h3><h4 id="博客-1"><a href="#博客-1" class="headerlink" title="博客"></a>博客</h4><h4 id="stream流对象的认识与使用-amp-stream流中方法精简总结"><a href="#stream流对象的认识与使用-amp-stream流中方法精简总结" class="headerlink" title="stream流对象的认识与使用&amp;stream流中方法精简总结"></a><a href="https://blog.csdn.net/m0_45899013/article/details/110230307?utm_medium=distribute.wap_relevant.none-task-blog-baidujs_title-7">stream流对象的认识与使用&amp;stream流中方法精简总结</a></h4><h4 id="方法精简"><a href="#方法精简" class="headerlink" title="方法精简"></a>方法精简</h4><p>allMatch    检查 Stream 中的所有元素，全部都通过检测则返回 true<br>anyMatch    检查 Stream 中的所有元素，全部都通过检测则返回 true<br>noneMatch    当流中每个元素都不符合该断言时才返回true<br>count    返回流中元素的总个数<br>max    返回stream中的最大值<br>min    返回stream中的最小值<br>sort    对stream中的元素排序<br>filter    过滤 Stream中的元素<br>map    将流中的一个值转换成一个新的值<br>collect    接收一个Collector实例，将流中元素收集成另外一个数据结构<br>collect(toList())    通过 Stream 生成一个列表<br>flatMap    将多个 Stream 连接成一个 Stream<br>reduce    从一组值中生成一个新的值<br>of    返回包含参数中单个指定元素的顺序Stream<br>distinct    去重<br>findFirst    返回流中第一个元素<br>findAny    返回流中的任意元素</p><h3 id="SerializedLambda-2021-5-8"><a href="#SerializedLambda-2021-5-8" class="headerlink" title="SerializedLambda 2021/5/8"></a>SerializedLambda 2021/5/8</h3><p><a href="https://blog.csdn.net/tengdazhang770960436/article/details/99960693">使用SerializedLambda代替字符串_彻底拆分，一切可控！-CSDN博客</a></p><p>SerializedLambda：</p><p>这里面函数式接口继承了Serializable接口，意思也就是说这个函数式接口是支持序列化的</p><p>函数式接口如果继承了Serializable，使用Lambda表达式来传递函数式接口时，编译器会为Lambda表达式生成一个writeReplace方法，这个生成的writeReplace方法会返回java.lang.invoke.SerializedLambda；可以从反射Lambda表达式的Class证明writeReplace的存在</p><p>实现原理</p><p>1、首先我们看最后一个方法Field findField(SerializableFunction, ?&gt; function)，该方法中第一步是通过SerializableFunction对象获取Class，即传递的方法引用，然后反射获取writeReplace()方法,并调用该方法获取导SerializedLambda对象。</p><p>2、SerializedLambda是Java8中提供，主要就是用于封装方法引用所对应的信息，主要的就是方法名、定义方法的类名、创建方法引用所在类。</p><p>3、拿到这些信息后，便可以通过反射获取对应的Field。</p><p>4、而在方法Field getField(SerializableFunction, ?&gt; function)中对获取到的Field进行缓存，避免每次都反射获取，造成资源浪费。</p><p>除此之外似乎还有一些值得思考的问题</p><p>writeReplace()方法是哪来的呢?</p><p>首先简单了解一下java.io.Serializable接口，该接口很常见，我们在持久化一个对象或者在RPC框架之间通信使用JDK序列化时都会让传输的实体类实现该接口，该接口是一个标记接口没有定义任何方法，但是该接口文档中有这么一段描述：</p><p>概要意思就是说，如果想在序列化时改变序列化的对象，可以通过在实体类中定义任意访问权限的Object writeReplace()来改变默认序列化的对象。</p><p>那么我们的定义的SerializableFunction中并没有定义writeReplace()方法，这个方法是哪来的呢？</p><p>代码中SerializableFunction,Function只是一个接口，但是其在最后必定也是一个实现类的实例对象，而方法引用其实是在运行时动态创建的，当代码执行到方法引用时,如People::getName，最后会经过</p><p>java.lang.invoke.LambdaMetafactory</p><p>java.lang.invoke.InnerClassLambdaMetafactory</p><p>去动态的创建实现类。而在动态创建实现类时则会判断函数式接口是否实现了Serializable，如果实现了，则添加writeReplace()</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><h3 id="Class-getResource和ClassLoader-getResource的区别和底层原理"><a href="#Class-getResource和ClassLoader-getResource的区别和底层原理" class="headerlink" title="Class.getResource和ClassLoader.getResource的区别和底层原理"></a>Class.getResource和ClassLoader.getResource的区别和底层原理</h3><h4 id="classpath概念"><a href="#classpath概念" class="headerlink" title="classpath概念"></a>classpath概念</h4><p>首先说一个概念，classpath，指的是编译后的class文件、xml、properties等配置文件所在的目录。比如，如果是maven项目，classpath为“项目名/target/classes”，如果是普通项目，可能是”项目名/bin”，或者”项目名/build/classes”等等。</p><p>getResource是java.lang.Class的方法，也就是由字节码对象调用。<br>getResource接受一个字符串参数，如果以”/”开头，就在classpath根目录下找（不会递归查找子目录），如果不以”/”开头，就在调用getResource的字节码对象所在目录下找（同样不会递归查找子目录）。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="魔法值-不同的处理方式重点在于业务和作用域"><a href="#魔法值-不同的处理方式重点在于业务和作用域" class="headerlink" title="魔法值(不同的处理方式重点在于业务和作用域)"></a>魔法值(不同的处理方式重点在于业务和作用域)</h3><p>避免魔法值的一些操作。</p><p><strong>一般魔法值都是不经常变动的。对于魔法值的处理要结合业务和作用域。</strong></p><p>​    在TV二轮考核中ActionMethod作用域在不同的类中，所以使用枚举类。</p><p>.1 静态常量</p><p>如果该值的作用域在一个类中或者同一个包下，一般可以使用静态常量来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FEMALE = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MALE = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attend</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FEMALE.equals(value)) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MALE.equals(value)) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是不是清晰了许多，原来 0 和 1 代表的是性别(当然需要配合你良好的变量命名习惯)。</p><p>2.2 使用接口</p><p>既然我们使用了静态常量那么我们可以将魔法值封装入接口也是可以的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">String FEMALE = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">String MALE = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.3 使用枚举</p><p>但是接口的意义在于提供抽象的功能而不是存储一些常量值，显然违背了接口设计的初衷。所以jdk1.5引入了枚举类型 enum。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">GenderEnum</span> </span>&#123;</span><br><span class="line">FEMALE,</span><br><span class="line">    </span><br><span class="line">MALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String转换成枚举类"><a href="#String转换成枚举类" class="headerlink" title="String转换成枚举类"></a>String转换成枚举类</h3><h3 id="数据库连接失败，找不到路径-2021-5-26"><a href="#数据库连接失败，找不到路径-2021-5-26" class="headerlink" title="数据库连接失败，找不到路径 2021/5/26"></a>数据库连接失败，找不到路径 2021/5/26</h3><p>原因：修改了数据库路径上的文件夹名称</p><h4 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h4><p>​        解决：环境变量路径设置</p><h4 id="错误1067"><a href="#错误1067" class="headerlink" title="错误1067"></a>错误1067</h4><p>​        解决：修改数据库的ini配置文件中的data路径</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TV第二轮考核学习笔记&quot;&gt;&lt;a href=&quot;#TV第二轮考核学习笔记&quot; class=&quot;headerlink&quot; title=&quot;TV第二轮考核学习笔记&quot;&gt;&lt;/a&gt;TV第二轮考核学习笔记&lt;/h1&gt;&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
